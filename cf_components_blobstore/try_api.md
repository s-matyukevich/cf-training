### Using Blobstore API

Now when you understand how blobstore works it is time to try it out.  But first we need to make some preparations.

1. Install `shyaml` This programm will help us to extract different parameters from yml configuration files.
  ```exec
  sudo apt-get install -y python-pip
  sudo pip install shyaml
  ```

1. Save blobstore CA sertificate. Cloufoundry signs all certificates using custom [Certificate Authority](https://en.wikipedia.org/wiki/Certificate_authority) So any component that needs to connect to the blobstore should use this certificate.
  ```exec
  cat ~/cf-deployment/deployment-vars.yml | shyaml get-value blobstore_tls.ca > ~/certs/blobstore-ca.pem
  ```
  As you might remember `~/cf-deployment/deployment-vars.yml` is a file generated by BOSH CLI where all parameters, including  generated credentials and certificates are stored.

1. Find blobstore IP (you can use `bosh vms` command for this) and update hosts file
  ```exec
  export blobstore_ip=$(bosh vms | grep blobstore | awk '{print $4}')
  sudo blobstore_ip=$blobstore_ip bash -c 'cat >> /etc/hosts <<EOF
  $blobstore_ip blobstore.service.cf.internal 
  EOF'
  ```
  Updating hosts file here is a kind of a trick and requires additional explanation. The thing is that CF components newer talks to each other using IP addresses. Instead they rely on consul to make DNS resolution for them. So if you ssh to any of the CF VMs, DNS name `blobstore.service.cf.internal` will be resolved to blobstore ip addres. But as we are going to access this address from our jumpbox we need to manually add the previous record to our hosts file.

1. Find credentials for blobstore basic auth.
  ```exec
  port=4443
  user="blobstore-user"
  pass=$(cat ~/cf-deployment/deployment-vars.yml | shyaml get-value blobstore_admin_users_password)
  ``` 
  As you might see values for blobstore user and port are hardcoded in the manifest or release. But you can always find out exact values for those parameters by sshing to blobstore VM and exploring the content of `var/vcap/jobs/blobstore/config` folder.

1. Trigger `sign` method
  ```exec
  write_url=$(curl --cacert ~/certs/blobstore-ca.pem --user $user:$pass "https://blobstore.service.cf.internal:$port/sign_for_put?path=/some-key&expires=16730564099")
  echo $write_url
  ```
  Now `write_url` contains md5 parameter that contains proper calculated signing hash as wel as `expires` parameter. Let's extract them to separate variables
  ```exec
  md5=$(echo $write_url | grep -oP 'md5=\K.*(?=&)')
  expires=$(echo $write_url | grep -oP 'expires=\K.*')
  ```
  We can't use `write_url` directly because it don't contains proper port number

1. Write some data
  ```exec
  curl --cacert ~/certs/blobstore-ca.pem --user $user:$pass "https://blobstore.service.cf.internal:$port/write/some-key?md5=$md5&expires=$expires" -X PUT -d some-data
  ```
  String `some-data` now should be written to `/some-key` bucket.

1. Read the data. (Signing process is almost the same with the exception that `sign` method is used instead of `sign_for_put`. Also basic auth is not required for read)
  ```exec
  read_url=$(curl --cacert ~/certs/blobstore-ca.pem --user $user:$pass "https://blobstore.service.cf.internal:$port/sign?path=/some-key&expires=16730564099")
  echo $read_url
  md5=$(echo $read_url | grep -oP 'md5=\K.*(?=&)')
  expires=$(echo $read_url | grep -oP 'expires=\K.*')
  curl --cacert ~/certs/blobstore-ca.pem "https://blobstore.service.cf.internal:$port/read/some-key?md5=$md5&expires=$expires" 
  ```
  You should see `some-data` as an output from the above command.

1. User public server to read the same bucket
  ```exec
  curl "http://blobstore.bosh-lite.com/read/some-key?md5=$md5&expires=$expires" 
  ```
